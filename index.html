<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">















  
  
  <link href="/woodi.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/woodi.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/woodi.github.io/css/main.css?v=5.1.0" rel="stylesheet" type="text/css">


  <meta name="keywords" content="Hexo, NexT">








  <link rel="shortcut icon" type="image/x-icon" href="/woodi.github.io/favicon.ico?v=5.1.0">






<meta property="og:type" content="website">
<meta property="og:title" content="Woooodi&#39;s Private Zone">
<meta property="og:url" content="http://woonoah.github.io/woodi.github.io/index.html">
<meta property="og:site_name" content="Woooodi&#39;s Private Zone">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Woooodi&#39;s Private Zone">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/woodi.github.io/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://woonoah.github.io/woodi.github.io/">





  <title> Woooodi's Private Zone </title>
</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/woodi.github.io/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Woooodi's Private Zone</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/woodi.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/woodi.github.io/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/woodi.github.io/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/11/17/windows键盘映射/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/11/17/windows键盘映射/" itemprop="url">
                  windows键盘映射
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-17T23:46:39+08:00">
                2019-11-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近把MacBook接到了以前台式的显示器上了。然后把以前落灰的机械键盘也拿了粗来。。。想要进一步体验一下码代码的快感。但是。接入之后。windows键盘的win键 映射成了 Mac上的command键、Windows上的alt -&gt; Mac上的option键。跟Mac键盘上完全相反。<br>由于平时工作的时候。已经习惯了Mac的键盘。所以在使用Windows键盘的时候，经常误操作。或者要想好久组合键是什么。。。<br>在经过几次使用iterm没保存然后直接退出的误操作之后。是在受不了了。网上开始搜索改建方法：<br>这里做一个笔记：</p>
<p>使用的软件是<a href="https://pqrs.org/osx/karabiner/index.html" target="_blank" rel="noopener">karabiner</a></p>
<p>设置的方式是：<br><img src="https://upload-images.jianshu.io/upload_images/1241385-0962c78e838532ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>记录一下，以供以后再次使用的时候，方便配置！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/08/27/DailyBrainStorm/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/08/27/DailyBrainStorm/" itemprop="url">
                  DailyBrainStorm
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-27T12:59:43+08:00">
                2019-08-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p> 写这篇的目的：好多时候没有更新文章，其实并不是没有在做研究，只不过有些小的知识点，并不值得洋洋洒洒的来一篇，故而开了这个tag，每当自己有什么小的研究和小的idea，能够记录下来</p>
</blockquote>
<h4 id="2019年08月27日"><a href="#2019年08月27日" class="headerlink" title="2019年08月27日"></a>2019年08月27日</h4><p>iOS tableview的headerView和footerView,<br>在创建的时候设置的frame，系统会根据宽高来添加约束，因此无法通过添加子视图与父视图之间的约束，来做到“子视图撑大父视图”这样。想要修改tableview的header、footer视图，可以在子视图布局完成之后添加回调，重新设置即可。<br><code>self.tableview.tableHeaderView = self.headerView;</code><br><code>self.tableview.tableFooterView = self.footerView;</code></p>
<h4 id="2019年09月11日"><a href="#2019年09月11日" class="headerlink" title="2019年09月11日"></a>2019年09月11日</h4><p>iOS label 默认设置lineBreakMode为省略号在右边<br>但是如果使用了NSParagraphStyle,则label设置的lineBreakMode就会失效，使用NSMutableParagraphStyle的lineBreakMode代替即可</p>
<h4 id="2019年09月19日"><a href="#2019年09月19日" class="headerlink" title="2019年09月19日"></a>2019年09月19日</h4><p>iOS的collectionView, 如果collectionview的frame不足以展示两个cell，则此时cell会居中显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">这里以左右滑动为例：collectionview的height为vHeight, cell的height为cHeight。默认collectionview的cell的item间距和item行间距都为0</span><br><span class="line">如果cHeight &lt; vHeight &lt; 2*cHeight, 此时</span><br><span class="line">eg:  vHeight = 100; cHeight = 70;</span><br><span class="line">此时cell居中展示， 上下间距15</span><br><span class="line"></span><br><span class="line">如果 2*cHeight &lt; vHeight &lt; 3*cHeight</span><br><span class="line">此时，view能只能展示两个cell，则两个cell分别位于view的top和bottom，剩下的距离为两个cell之间的margin</span><br><span class="line"></span><br><span class="line">如果 3*cHeight &lt; vHeight &lt; 4*cHeight</span><br><span class="line">此时，view能展示三个cell，则第一个，第三个分别位于view的顶部和底部，然后中间一个居中展示，(vHeight - 3*cHeight)/2为三个cell之间的间距</span><br><span class="line"></span><br><span class="line">如果 4*cHeight &lt; vHeight &lt; 5*cHeight</span><br><span class="line">此时，view能展示四个cell，则第一个，第四个分别位于view的顶部和底部，然后剩下的两个在中间展示，(vHeight - 4*cHeight)/3为三个cell之间的间距</span><br><span class="line"></span><br><span class="line">剩下的以此类推</span><br></pre></td></tr></table></figure></p>
<h4 id="2019年09月27日"><a href="#2019年09月27日" class="headerlink" title="2019年09月27日"></a>2019年09月27日</h4><p>iOS UIView提供的方法中，有转换坐标系的方法，比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;</span><br><span class="line">- (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;</span><br><span class="line">- (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;</span><br><span class="line">- (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;</span><br></pre></td></tr></table></figure></p>
<p>项目中用到了<code>convertRect: toView:</code>方法<br>总结一下各个参数的含义。</p>
<ol>
<li>调用者：转换前的view的父类调用</li>
<li>rect：转换前的view的frame</li>
<li>toView：转换后的坐标系view</li>
</ol>
<h4 id="2019年10月17日"><a href="#2019年10月17日" class="headerlink" title="2019年10月17日"></a>2019年10月17日</h4><p>影响iOS viewController dealloc的方法小结</p>
<ol>
<li><p>VC中的block强引用了self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eg: AFN的请求</span><br><span class="line">在回调中引用了self</span><br></pre></td></tr></table></figure>
</li>
<li><p>dispatch_after中强引用self</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">如下面的代码中这样，不引用self，则会直接销毁</span><br><span class="line">- (void)normalDispatchAfter &#123;</span><br><span class="line">    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;5s later&quot;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2019-10-18 16:49:56.568192+0800 GCDStrongReferenceDemo[15628:3535241] ~~~~~~~~~~~~~~~~~~~~SecViewController - dealloc</span><br><span class="line">2019-10-18 16:50:00.070705+0800 GCDStrongReferenceDemo[15628:3535241] 5s later</span><br><span class="line">但是，after中的代码由于是添加到Runloop中了，所以5s之后，仍然会调用</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>同样的，以前怀疑的dispatch_group/notify等方法也不会强引用self<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">    __weak typeof (self) weakSelf = self;</span><br><span class="line">    dispatch_group_t group = dispatch_group_create();</span><br><span class="line">    dispatch_queue_t queue = dispatch_queue_create(&quot;com.demo.GCDStrongReference&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        dispatch_group_enter(group);</span><br><span class="line">//        NSLog(@&quot;~~~~~~~~~~~~~~~~~~~~1111111111 enter&quot;);</span><br><span class="line">        [weakSelf logWithInfo:@&quot;11111111  enter&quot;];</span><br><span class="line">        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">//            NSLog(@&quot;~~~~~~~~~~~~~~~~~~~~1111111111 leave&quot;);</span><br><span class="line">            [weakSelf logWithInfo:@&quot;11111111  leave&quot;];</span><br><span class="line">            dispatch_group_leave(group);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">        dispatch_group_enter(group);</span><br><span class="line">//        NSLog(@&quot;~~~~~~~~~~~~~~~~~~~~222222222222&quot;);</span><br><span class="line">        [weakSelf logWithInfo:@&quot;22222222222222&quot;];</span><br><span class="line">        dispatch_group_leave(group);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    dispatch_group_notify(group, queue, ^&#123;</span><br><span class="line">//        NSLog(@&quot;~~~~~~~~~~~~~~~~~~~~notify&quot;);</span><br><span class="line">        [weakSelf logWithInfo:@&quot;notify&quot;];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    打印结果也是会直接dealloc</span><br><span class="line">    2019-10-18 16:58:27.441916+0800 GCDStrongReferenceDemo[15858:3547133] ~~~~~~~~~~~~~~~~~~~~SecViewController - 11111111  enter</span><br><span class="line">    2019-10-18 16:58:27.441926+0800 GCDStrongReferenceDemo[15858:3547358] ~~~~~~~~~~~~~~~~~~~~SecViewController - 22222222222222</span><br><span class="line">    2019-10-18 16:58:28.901496+0800 GCDStrongReferenceDemo[15858:3546983] ~~~~~~~~~~~~~~~~~~~~SecViewController - dealloc</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>总结：如果在block中改为弱引用，则可以避免 __weak typeof(self) weakSelf = self;</p>
</blockquote>
<h4 id="2019年10月30日-setContentHuggingPriority为抗拉伸优先级"><a href="#2019年10月30日-setContentHuggingPriority为抗拉伸优先级" class="headerlink" title="2019年10月30日 setContentHuggingPriority为抗拉伸优先级"></a>2019年10月30日 setContentHuggingPriority为抗拉伸优先级</h4><p>以前只是按照字面意思，以为是<code>拉伸优先级</code>，结果是<code>抗拉伸优先级</code>:<br>即： 优先级越高，越不容易被拉伸，优先级越低，则越容易被拉伸<br>同理，<code>setContentCompressionResistancePriority</code>为抗压缩优先级<br>即：优先级越高，越不容易被压缩，优先级越低，越容易被压缩。<br>默认情况下: HuggingPriority == 250,  CompressionResistancePriority == 750</p>
<h4 id="2019年11月05日-可以在不借助第三个变量的情况下使用异或位运算交换两个数的值"><a href="#2019年11月05日-可以在不借助第三个变量的情况下使用异或位运算交换两个数的值" class="headerlink" title="2019年11月05日 可以在不借助第三个变量的情况下使用异或位运算交换两个数的值"></a>2019年11月05日 可以在不借助第三个变量的情况下使用异或位运算交换两个数的值</h4><p>a = 10<br>b = 8<br>a = a ^ b<br>b = a ^ b<br>a = a ^ b<br>结果，a = 8, b = 10</p>
<h4 id="2019年11月07日"><a href="#2019年11月07日" class="headerlink" title="2019年11月07日"></a>2019年11月07日</h4><p>iOS13之后，初始化的时候通过约束设置的frame之后，再手动修改frame值时无效。</p>
<h4 id="2019年11月13日"><a href="#2019年11月13日" class="headerlink" title="2019年11月13日"></a>2019年11月13日</h4><p>给iOS Layer添加basic动画的时候，设置fromValue和toValue的值，都是根据初始值的相对大小<br>eg:<br>假如自己画了一个竖着的时钟时针，那么</p>
<ol>
<li>fromValue如果设置为0，toValue设置为M_PI,则就是从竖直状态开始,顺时针转动180度。</li>
<li>如果fromValue为3 <em> M_PI/2, toValue为 5 </em> M_PI/2, 则就是从9点钟放心顺时针转到3点钟方向。</li>
<li>如果fromValue = M_PI/2, toValue = 0, 则就是 逆时针转动90度，从3点钟方向，到12点钟方向。<br>以此类推，<br>如果初始的时候，时针不是竖直的，而是<code>沿着x轴水平向右</code>的。<br>那么动画的效果又会截然不同：</li>
<li>fromValue = 0, toValue = M_PI, 3点钟方向 顺时针转到9点钟方向</li>
<li>fromValue = 3 <em> M_PI/2, toValue = 5 </em> M_PI/2, 则12点钟方向 顺时针转到 6点钟方向</li>
<li>fromValue = M_PI/2, toValue = 0, 则 6点钟方向，逆时针 到3点钟方向。</li>
</ol>
<h4 id="2019年11月15日"><a href="#2019年11月15日" class="headerlink" title="2019年11月15日"></a>2019年11月15日</h4><p>swift中的didset在初始化方法中调用无效. 可以使用kvo代替。</p>
<h4 id="2019年11月17日"><a href="#2019年11月17日" class="headerlink" title="2019年11月17日"></a>2019年11月17日</h4><h5 id="iOS画弧度和内切圆的时候。一些技巧可以画出扇形、饼状图"><a href="#iOS画弧度和内切圆的时候。一些技巧可以画出扇形、饼状图" class="headerlink" title="iOS画弧度和内切圆的时候。一些技巧可以画出扇形、饼状图"></a>iOS画弧度和内切圆的时候。一些技巧可以画出扇形、饼状图</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">    [super viewDidLoad];</span><br><span class="line">    // Do any additional setup after loading the view.</span><br><span class="line">    </span><br><span class="line">    UIView *animateView = [[UIView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];</span><br><span class="line">    </span><br><span class="line">//    UIBezierPath *path = [UIBezierPath bezierPathWithOvalInRect:animateView.bounds];</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithArcCenter:CGPointMake(50, 50) radius:50 startAngle:3*M_PI_2 endAngle:7*M_PI_2 clockwise:YES];</span><br><span class="line">    </span><br><span class="line">    CAShapeLayer *layer = [CAShapeLayer layer];</span><br><span class="line">    layer.frame = animateView.bounds;</span><br><span class="line">    layer.path = path.CGPath;</span><br><span class="line">//    layer.strokeStart = 0.1;   //如果不加动画，这里可以直接设置起始和终点位置。如果要加动画，则设置动画的fromValue、toValue替代</span><br><span class="line">//    layer.strokeEnd = 0.5;</span><br><span class="line">    layer.lineWidth = 90;       //如果想要画扇形。设置lineWidth [0, 2 * radius), 当lineWidth = 2*radius的时候，画出来的是饼状图</span><br><span class="line">//    layer.lineCap = kCALineCapRound; //想要画扇形、饼状图。不要设置kCALineCapRound此属性。</span><br><span class="line">    layer.strokeColor = [UIColor redColor].CGColor;</span><br><span class="line">    layer.fillColor = [UIColor yellowColor].CGColor;</span><br><span class="line">    self.animateLayer = layer;</span><br><span class="line">    </span><br><span class="line">    [animateView.layer addSublayer:layer];</span><br><span class="line">    </span><br><span class="line">    [self.view addSubview:animateView];</span><br><span class="line">    </span><br><span class="line">    UIButton *btn = [UIButton buttonWithType:(UIButtonTypeSystem)];</span><br><span class="line">    [btn setTitle:@&quot;animate&quot; forState:(UIControlStateNormal)];</span><br><span class="line">    btn.frame = CGRectMake(100, 250, 100, 44);</span><br><span class="line">    [btn addTarget:self action:@selector(addAnimationToCircle) forControlEvents:(UIControlEventTouchUpInside)];</span><br><span class="line">    [self.view addSubview:btn];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)addAnimationToCircle &#123;</span><br><span class="line">    CABasicAnimation *animate = [CABasicAnimation animationWithKeyPath:@&quot;strokeEnd&quot;];</span><br><span class="line">    animate.repeatCount = 1;</span><br><span class="line">    animate.removedOnCompletion = NO;</span><br><span class="line">    animate.fillMode = kCAFillModeForwards;</span><br><span class="line">    animate.duration = 2;</span><br><span class="line">//    animate.fromValue = @(0.1);</span><br><span class="line">//    animate.toValue = @(0.5);</span><br><span class="line">    animate.fromValue = @(0);</span><br><span class="line">    animate.toValue = @(1);</span><br><span class="line">    </span><br><span class="line">    [self.animateLayer addAnimation:animate forKey:@&quot;circleAnimate&quot;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2019年11月18日"><a href="#2019年11月18日" class="headerlink" title="2019年11月18日"></a>2019年11月18日</h4><p>UIcollectionView, 设置不同section的headerView高度不同<br>collectionview不像tableview，有设置headerview高度的代理方法。collectionview只有一个-viewForSupplementaryElementOfKind方法。<br>因此在此方法中。可以获取到layout中的headerReferenceSize，然后手动修改即可<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//collectionview初始化的时候layout的设置</span><br><span class="line">UICollectionViewFlowLayout *layout = [[UICollectionViewFlowLayout alloc] init];</span><br><span class="line">layout.itemSize                    = CGSizeMake(WIDTH / _colNum, itemHeight);</span><br><span class="line">layout.minimumLineSpacing          = 0;</span><br><span class="line">layout.minimumInteritemSpacing     = 0;</span><br><span class="line">layout.headerReferenceSize = CGSizeMake(WIDTH, 10);</span><br><span class="line">layout.footerReferenceSize = CGSizeMake(WIDTH, 10);</span><br><span class="line">self.collectionView.collectionViewLayout = layout;</span><br><span class="line"></span><br><span class="line">//viewForSupplementaryElementOfKind代理方法中修改layout的方法</span><br><span class="line">CGFloat headerHeight = indexPath.section == 0 ? 0 : 10;</span><br><span class="line">UICollectionViewFlowLayout *layout = (id)self.collectionView.collectionViewLayout;</span><br><span class="line">layout.headerReferenceSize = CGSizeMake(WIDTH, headerHeight);</span><br><span class="line">self.collectionView.collectionViewLayout = layout;</span><br><span class="line"></span><br><span class="line">以此达到第一栏的headerView高度为0，其他栏的高度为10</span><br></pre></td></tr></table></figure></p>
<h4 id="2019年11月19日"><a href="#2019年11月19日" class="headerlink" title="2019年11月19日"></a>2019年11月19日</h4><p>自己画的线或者弧，添加strokeEnd动画的时候，会把绘制过程展现出来<br>旋转、缩放等动画都跟锚点有关系，锚点也跟layer的frame有关系。这些值都必须设置锚点才会有效果</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/07/17/iOS-performSelector相关操作/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/07/17/iOS-performSelector相关操作/" itemprop="url">
                  iOS performSelector相关操作
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-17T13:59:26+08:00">
                2019-07-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>今天遇到一个问题，先来给各位看官看一下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">NSLog(@&quot;hello world 1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (void)backGroundThread&#123;</span><br><span class="line">NSLog(@&quot;—hello world2—&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问：这段代码会打印什么？</strong></p>
<p><em>可能很多人会开始猜了。这里先卖个关子，带着你的疑问继续看下去吧。</em></p>
<h4 id="首先，总体来看一下苹果提供的performSelector系列的API"><a href="#首先，总体来看一下苹果提供的performSelector系列的API" class="headerlink" title="首先，总体来看一下苹果提供的performSelector系列的API"></a>首先，总体来看一下苹果提供的<code>performSelector</code>系列的API</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (NSThreadPerformAdditions)</span><br><span class="line"></span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">// equivalent to the first method with kCFRunLoopCommonModes</span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line"></span><br><span class="line">/****************     Delayed perform     ******************/</span><br><span class="line"></span><br><span class="line">@interface NSObject (NSDelayedPerforming)</span><br><span class="line"></span><br><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</span><br><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</span><br><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget selector:(SEL)aSelector object:(nullable id)anArgument;</span><br><span class="line">+ (void)cancelPreviousPerformRequestsWithTarget:(id)aTarget;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>可以看到，这几个是苹果提供的常用的多线程事件相关操作。用这几个方法，我们可以在子线程处理某些方法、拉回到主线程做一些操作，在当前线程延迟多久做一些操作等等。<br><code>performSelectorInBackground</code>这个就不说了。</p>
<p>今天主要来研究下带有<code>waitUntilDone</code>参数的方法，即<code>performSelectorOnMainThread: withObject: waitUntilDone:</code>和<code>performSelector: onThread: withObject: waitUntilDone:</code>两个方法：<br>先来看下官方是怎么解释waitUntilDone的wait这个参数的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait</span><br><span class="line">A Boolean that specifies whether the current thread blocks until after the specified selector is performed on the receiver on the main thread. </span><br><span class="line">Specify YES to block this thread; otherwise, specify NO to have this method return immediately.</span><br><span class="line">If the current thread is also the main thread, and you specify YES for this parameter, the message is delivered and processed immediately.</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>可以看到，这个参数是个bool类型，如果为YES，则会阻塞当前线程直到指定的方法执行完成才返回。<br>如果为NO, 则会立即返回。</p>
</blockquote>
<h4 id="这时如果把上面例子中的代码改为这样："><a href="#这时如果把上面例子中的代码改为这样：" class="headerlink" title="这时如果把上面例子中的代码改为这样："></a>这时如果把上面例子中的代码改为这样：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:YES];</span><br><span class="line">NSLog(@&quot;hello world 1&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">- (void)backGroundThread&#123;</span><br><span class="line">NSLog(@&quot;—hello world2—&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时结果是什么？<br>相信大家都能看出来，肯定是 <code>先打印hello world 2，然后再打印hello  world1的</code>.<br>然后回归到最上面的问题。<br>结果是什么呢？<br>好奇的小伙伴们可以项目中跑一下看看：<br>其实结果是：<strong><code>只有hello world 1</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-07-17 14:24:38.417458+0800 RunloopDemo[4298:394797] hello world 1</span><br></pre></td></tr></table></figure></p>
<p>这是为什么呢？为什么performSelector要执行的方法没有走呢？<br>这个瞎猜是没用的， 我们只能去查苹果是怎么解释<code>performSelector:onThread:withObject:waitUntilDone:</code>的了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">## Discussion</span><br><span class="line"></span><br><span class="line">You can use this method to deliver messages to other threads in your application. </span><br><span class="line">The message in this case is a method of the current object that you want to execute on the target thread. </span><br><span class="line"></span><br><span class="line">This method queues the message on the run loop of the target thread using the default run loop modes—that is, </span><br><span class="line">the modes associated with the [NSRunLoopCommonModes]  constant. </span><br><span class="line">As part of its normal run loop processing, the target thread dequeues the message (assuming it is running in one of the default run loop modes) and invokes the desired method.</span><br><span class="line"></span><br><span class="line">You cannot cancel messages queued using this method. If you want the option of canceling a message on the current thread, </span><br><span class="line">you must use either the [performSelector:withObject:afterDelay:] or [performSelector:withObject:afterDelay:inModes:] method.</span><br><span class="line"></span><br><span class="line">### Special Considerations</span><br><span class="line"></span><br><span class="line">This method registers with the runloop of its current context, and depends on that runloop being run on a regular basis to perform correctly. </span><br><span class="line">One common context where you might call this method and end up registering with a runloop that is not automatically run on a regular basis is when being invoked by a dispatch queue. </span><br><span class="line">If you need this type of functionality when running on a dispatch queue, you should use [dispatch_after] and related methods to get the behavior you want.</span><br></pre></td></tr></table></figure></p>
<p>可以看到：<br>此方法是为了把当前线程的对象传递给别的线程的，此方法会被加入到目标线程的runloop队列中，该runloop使用默认mode–NSRunLoopCommonModes。当该线程的runloop执行的时候，它会以此出队列，然后执行想要执行的方法。<br>由此可以得出结论，<code>此方法是依赖于线程的runloop的</code>。<br>而上面例子中，我们使用了<code>dispatch_async</code>创建了一个子线程，我们知道，<code>子线程的runloop是默认不启动的</code>,因此，我们添加对应的方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// Do any additional setup after loading the view.</span><br><span class="line"></span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line"></span><br><span class="line">[self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;hello world 1&quot;);</span><br><span class="line"></span><br><span class="line">NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">[currentRunLoop run];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)backGroundThread&#123;</span><br><span class="line">NSLog(@&quot;—hello world2—&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>果然，此时再打印，结果就正常了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-07-17 14:42:18.784324+0800 RunloopDemo[4477:428656] hello world 1</span><br><span class="line">2019-07-17 14:42:18.784650+0800 RunloopDemo[4477:428656] —hello world2—</span><br></pre></td></tr></table></figure></p>
<p>但是，经过一系列的操作，我发现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">[currentRunLoop run];</span><br></pre></td></tr></table></figure></p>
<p>两行代码放的位置，也是有讲究的。<br><img src="https://upload-images.jianshu.io/upload_images/1241385-bb5ae8163c7f9d24.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>一共1、2、3三种情况，结果又不尽相同。</p>
<ol>
<li><p>假如放在1️⃣的位置，结果如何呢？又变成<code>只有hello world 1了</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-07-17 14:47:44.859178+0800 RunloopDemo[4549:445631] hello world 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>2️⃣的位置呢？<code>只有hello world 2了</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019-07-17 14:48:29.820267+0800 RunloopDemo[4566:448005] —hello world2—</span><br></pre></td></tr></table></figure>
</li>
<li><p>位置3️⃣，结果就是上面那样，<code>是正常的</code>。</p>
</li>
</ol>
<p>是不是很奇怪呢？<br>因此再来看下<code>[[NSRunLoop currentRunLoop] run]</code>方法苹果是怎么解释的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">### Discussion</span><br><span class="line"></span><br><span class="line">If no input sources or timers are attached to the run loop, this method exits immediately; otherwise, it runs the receiver in the `NSDefaultRunLoopMode`by repeatedly invoking [runMode:beforeDate:].</span><br><span class="line">In other words, this method effectively begins an infinite loop that processes data from the run loop’s input sources and timers. </span><br><span class="line"></span><br><span class="line">Manually removing all known input sources and timers from the run loop is not a guarantee that the run loop will exit. </span><br><span class="line">macOS can install and remove additional input sources as needed to process requests targeted at the receiver’s thread. </span><br><span class="line">Those sources could therefore prevent the run loop from exiting. </span><br><span class="line"></span><br><span class="line">If you want the run loop to terminate, you shouldn&apos;t use this method. </span><br><span class="line">Instead, use one of the other run methods and also check other arbitrary conditions of your own, in a loop. A simple example would be:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">BOOL shouldKeepRunning = YES; // global</span><br><span class="line">NSRunLoop *theRL = [NSRunLoop currentRunLoop];</span><br><span class="line">while (shouldKeepRunning &amp;&amp; [theRL runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]]);</span><br><span class="line"></span><br><span class="line">where `shouldKeepRunning` is set to `NO`somewhere else in the program.</span><br></pre></td></tr></table></figure></p>
<p>同样可以看到，RunLoop的run方法，在有输入源或者定时器的情况下，是重复的调用<code>runMode:beforeDate:</code>方法，换句话说，他是一个无限的循环，而且手动移除输入源和定时器并不能保证runloop会退出。所以苹果建议我们使用<code>runMode:beforeDate:</code>，并且给了下面一个标准的写法。<br>所以，我们上面的代码就可以改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">//[currentRunLoop run];</span><br><span class="line">[currentRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br></pre></td></tr></table></figure></p>
<p>此时，放置在2️⃣、3️⃣位置都是正常运行的了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">那位置1️⃣呢？仔细想想也是可以理解的，</span><br><span class="line">因为run方法中说了，如果输入源或定时器都没有的情况下，runloop是直接退出的。</span><br><span class="line">在位置1️⃣的时候开启runloop，此时并没有输入源加入, 所以此时runloop直接就退出了。</span><br><span class="line">（performSelector:onThread:withObject:waitUntilDone: 方法会把方法作为输入源添加到runloop中),</span><br><span class="line">所以2️⃣、3️⃣位置的时候，就不会出现此问题。</span><br></pre></td></tr></table></figure></p>
<h4 id="那再来看下拉回到主线程的方法"><a href="#那再来看下拉回到主线程的方法" class="headerlink" title="那再来看下拉回到主线程的方法"></a>那再来看下拉回到主线程的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br></pre></td></tr></table></figure>
<p>因为主线程的Runloop是默认开启的，所以不需要我们来处理。<br>把最上方中方法改为<code>performSelectorOnMainThread</code>，然后<code>waitUntilDone</code>参数为<code>YES</code>的时候，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-07-17 15:05:58.550527+0800 RunloopDemo[4714:483346] —hello world2—</span><br><span class="line">2019-07-17 15:05:58.550725+0800 RunloopDemo[4714:483400] hello world 1</span><br></pre></td></tr></table></figure></p>
<p><code>waitUntilDone</code>参数为<code>NO</code>的时候，结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2019-07-17 15:06:52.652589+0800 RunloopDemo[4736:485901] hello world 1</span><br><span class="line">2019-07-17 15:06:52.661368+0800 RunloopDemo[4736:485839] —hello world2—</span><br></pre></td></tr></table></figure></p>
<p>可以看出，此参数大致可以按“同步”、“异步”的方式来理解。</p>
<h4 id="因此，可以得出结论！！！！"><a href="#因此，可以得出结论！！！！" class="headerlink" title="因此，可以得出结论！！！！"></a>因此，可以得出结论！！！！</h4><blockquote>
<p>在方法<code>- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait</code>中， 执行方法的时候，是把输入源添加到对应线程的RunLoop中的，但是RunLoop此时并没有启动，所以方法不用调用。话句话说：<strong><code>方法的调用顺序取决于RunLoop的启动时机</code></strong>，参照<code>- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</code>方法的结果，我们可以知道，RunLoop的启动时机应该是在当前线程调用方法作用域的最后位置。</p>
</blockquote>
<p>最终代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">// Do any additional setup after loading the view.</span><br><span class="line"></span><br><span class="line">//    [self threadInfo:@&quot;UI THREAD&quot;];</span><br><span class="line">dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^&#123;</span><br><span class="line">//        [self threadInfo:@&quot;dispatch async&quot;];</span><br><span class="line"></span><br><span class="line">//        [self performSelector:@selector(backGroundThread) onThread:[NSThread currentThread] withObject:nil waitUntilDone:NO];</span><br><span class="line">[self performSelectorOnMainThread:@selector(backGroundThread) withObject:nil waitUntilDone:NO];</span><br><span class="line">//        [self performSelectorInBackground:@selector(backGroundThread) withObject:nil];</span><br><span class="line">//        [self performSelector:@selector(backGroundThread) withObject:nil afterDelay:2 inModes:@[NSDefaultRunLoopMode]];</span><br><span class="line">//        [self performSelector:@selector(backGroundThread) withObject:nil afterDelay:(2)];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;hello world 1&quot;);</span><br><span class="line"></span><br><span class="line">NSRunLoop *currentRunLoop = [NSRunLoop currentRunLoop];</span><br><span class="line">//[currentRunLoop run];</span><br><span class="line">[currentRunLoop runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)backGroundThread&#123;</span><br><span class="line">NSLog(@&quot;—hello world2—&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="举一反三"><a href="#举一反三" class="headerlink" title="举一反三"></a>举一反三</h4><p>苹果提供的别的API, 诸如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray&lt;NSRunLoopMode&gt; *)modes;</span><br><span class="line">- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;</span><br></pre></td></tr></table></figure></p>
<p>假如他们也是在子线程中调用的话，我们同样也是需要手动开启runloop的。</p>
<h4 id="以上。END"><a href="#以上。END" class="headerlink" title="以上。END"></a>以上。END</h4>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/07/12/iOS根据传入的值创建键值相同的字典/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/07/12/iOS根据传入的值创建键值相同的字典/" itemprop="url">
                  iOS根据传入的值创建键值相同的字典
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-12T12:13:10+08:00">
                2019-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* This macro is a helper for making view dictionaries for +constraintsWithVisualFormat:options:metrics:views:.  </span><br><span class="line">NSDictionaryOfVariableBindings(v1, v2, v3) is equivalent to [NSDictionary dictionaryWithObjectsAndKeys:v1, @&quot;v1&quot;, v2, @&quot;v2&quot;, v3, @&quot;v3&quot;, nil];</span><br><span class="line">*/</span><br><span class="line">#define NSDictionaryOfVariableBindings(...) _NSDictionaryOfVariableBindings(@&quot;&quot; # __VA_ARGS__, __VA_ARGS__, nil)</span><br><span class="line">UIKIT_EXTERN  NSDictionary *_NSDictionaryOfVariableBindings(NSString *commaSeparatedKeysString, __nullable id firstValue, ...) NS_AVAILABLE_IOS(6_0);</span><br></pre></td></tr></table></figure>
<p>摘自<a href="https://developer.apple.com/library/archive/samplecode/ViewTransitions/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007411" target="_blank" rel="noopener">Apple Sample</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/05/07/AutoLayout是这么进行自动布局的/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/05/07/AutoLayout是这么进行自动布局的/" itemprop="url">
                  AutoLayout是这么进行自动布局的
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-07T19:19:15+08:00">
                2019-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>AutoLayout底层实现为Cassowary算法</p>
<p>Cassowary是以高效的界面线性方程求解算法被提出来的，他解决的是界面的线性规划问题，而线性规划问题的解法是simplex算法</p>
<p>iOS12之前 AutoLayout存在的性能问题在<br><a href="https://developer.apple.com/videos/play/wwdc2018/220/" target="_blank" rel="noopener">WWDC 2018 202 session</a>中介绍</p>
<hr>
<h4 id="Auto-Layout-的生命周期"><a href="#Auto-Layout-的生命周期" class="headerlink" title="Auto Layout 的生命周期"></a>Auto Layout 的生命周期</h4><p>Auto Layout 不只有布局算法 Cassowary，还包含了布局在运行时的生命周期等一整套布局引擎系统，用来统一管理布局的创建、更新和销毁。了解 Auto Layout 的生命周期，是理解它的性能相关话题的基础。这样，在遇到问题，特别是性能问题时，我们才能从根儿上找到原因，从而避免或改进类似的问题。</p>
<p>这一整套布局引擎系统叫作 Layout Engine ，是 Auto Layout 的核心，主导着整个界面布局。</p>
<p>每个视图在得到自己的布局之前，Layout Engine 会将视图、约束、优先级、固定大小通过计算转换成最终的大小和位置。在 Layout Engine 里，每当约束发生变化，就会触发 Deffered Layout Pass，完成后进入监听约束变化的状态。当再次监听到约束变化，即进入下一轮循环中。整个过程如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1241385-650ea7eff36ddbc6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Layout Engine 界面布局过程"></p>
<p>图中， Constraints Change 表示的就是约束变化，添加、删除视图时会触发约束变化。Activating 或 Deactivating，设置 Constant 或 Priority 时也会触发约束变化。Layout Engine 在碰到约束变化后会重新计算布局，获取到布局后调用 superview.setNeedLayout()，然后进入 Deferred Layout Pass。</p>
<p>Deferred Layout Pass 的主要作用是做容错处理。如果有些视图在更新约束时没有确定或缺失布局声明的话，会先在这里做容错处理。</p>
<p>接下来，Layout Engine 会从上到下调用 layoutSubviews() ，通过 Cassowary 算法计算各个子视图的位置，算出来后将子视图的 frame 从 Layout Engine 里拷贝出来。</p>
<p>在这之后的处理，就和手写布局的绘制、渲染过程一样了。</p>
<hr>
<h4 id="我们使用AutoLayout的方式有以下两种："><a href="#我们使用AutoLayout的方式有以下两种：" class="headerlink" title="我们使用AutoLayout的方式有以下两种："></a>我们使用AutoLayout的方式有以下两种：</h4><ol>
<li>使用iOS提供的基于AutoLayout封装的<code>UIStackView</code><br>其实他更加类似于前端的<code>flexbox</code>布局思路，但是<strong>他有一个要求，就是必须是iOS9之后才可以使用</strong></li>
</ol>
<ol start="2">
<li>另外一个，就是我们直接基于AutoLayout封装成库<br>使用DSL(Domain Specific Language)语言来处理页面布局的方式<br><a href="https://github.com/WooNoah/STMAssembleView" target="_blank" rel="noopener">https://github.com/WooNoah/STMAssembleView</a> (forked from <a href="https://github.com/ming1016/STMAssembleView" target="_blank" rel="noopener">ming1016/STMAssembleView</a>)</li>
</ol>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ol>
<li><p>使用AutoLayout, 要多使用UIView的<code>Compression Resistance Priority</code>和<code>Hugging Priority</code>，<br>可以参考<a href="https://github.com/WooNoah/showAutoLayout" target="_blank" rel="noopener">这个demo</a></p>
</li>
<li><h5 id="AutoLayout的一些基本概念"><a href="#AutoLayout的一些基本概念" class="headerlink" title="AutoLayout的一些基本概念"></a>AutoLayout的一些基本概念</h5></li>
</ol>
<ul>
<li>利用约束来控制视图的大小和位置，系统会在运行时通过设置的约束计算得到frame再绘制屏幕</li>
<li>两个属性Content Compression Resistance（排挤，值越高越固定）和Content Hugging（拥抱）,Masonry代码如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//content hugging 为1000</span><br><span class="line">[view setContentHuggingPriority:UILayoutPriorityRequired</span><br><span class="line">forAxis:UILayoutConstraintAxisHorizontal];</span><br><span class="line"></span><br><span class="line">//content compression 为250</span><br><span class="line">[view setContentCompressionResistancePriority:UILayoutPriorityDefaultLow</span><br><span class="line">forAxis:UILayoutConstraintAxisHorizontal];</span><br></pre></td></tr></table></figure>
<ul>
<li>multipler属性表示约束值为约束对象的百分比，在Masonry里有对应的multipliedBy函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//宽度为superView宽度的20%</span><br><span class="line">make.width.equalTo(superView.mas_width).multipliedBy(0.2);</span><br></pre></td></tr></table></figure>
<ul>
<li>AutoLayout下UILabel设置多行计算需要设置preferredMaxLayoutWidth</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label.preferredMaxWidth = [UIScreen mainScreen].bounds.size.width - margin - padding;</span><br></pre></td></tr></table></figure>
<ul>
<li>preferredMaxLayoutWidth用来制定最大的宽，一般用在多行的UILabel中</li>
<li>systemLayoutSizeFittingSize方法能够获得view的高度</li>
<li>iOS7有两个很有用的属性，topLayoutGuide和bottomLayoutGuide，这个两个主要是方便获取UINavigationController和UITabBarController的头部视图区域和底部视图区域。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//Masonry直接支持这个属性</span><br><span class="line">make.top.equalTo(self.mas_topLayoutGuide);</span><br></pre></td></tr></table></figure>
<h5 id="3-AutoLayout关于更新的几个方法的区别"><a href="#3-AutoLayout关于更新的几个方法的区别" class="headerlink" title="3.AutoLayout关于更新的几个方法的区别"></a>3.<a href="https://github.com/ming1016/study/wiki/Masonry#autolayout%E5%85%B3%E4%BA%8E%E6%9B%B4%E6%96%B0%E7%9A%84%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener"></a>AutoLayout关于更新的几个方法的区别</h5><ul>
<li>setNeedsLayout：告知页面需要更新，但是不会立刻开始更新。执行后会立刻调用layoutSubviews。</li>
<li>layoutIfNeeded：告知页面布局立刻更新。所以一般都会和setNeedsLayout一起使用。如果希望立刻生成新的frame需要调用此方法，利用这点一般布局动画可以在更新布局后直接使用这个方法让动画生效。</li>
<li>layoutSubviews：系统重写布局</li>
<li>setNeedsUpdateConstraints：告知需要更新约束，但是不会立刻开始</li>
<li>updateConstraintsIfNeeded：告知立刻更新约束</li>
<li>updateConstraints：系统更新约束</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">针对Auto Layout的生命周期，我是这么理解的：</span><br><span class="line">Auto Layout拥有一套Layout Engine引擎，由它来主导页面的布局。</span><br><span class="line">App启动后，主线程的Run Loop会一直处于监听状态，</span><br><span class="line">当约束发生变化后会触发Deffered Layout Pass（延迟布局传递），</span><br><span class="line">在里面做容错处理（约束丢失等情况）并把view标识为dirty状态，然后Run Loop再次进入监听阶段。</span><br><span class="line">当下一次刷新屏幕动作来临（或者是调用layoutIfNeeded）时，</span><br><span class="line">Layout Engine 会从上到下调用 layoutSubviews() ，通过 Cassowary算法计算各个子视图的位置，</span><br><span class="line">算出来后将子视图的frame从Layout Engine拷贝出来，接下来的过程就跟手写frame是一样的了。</span><br></pre></td></tr></table></figure>
<p>把循环这部分总结了一下：<br><em>触发约束变化 —&gt; Layout Engine就需要重新计算布局，会先获取到当前的布局，调用SuperView.SetNeedLayout() —&gt; Deffered Layout Pass进行监听 —&gt; Layout Engine 从上到下调用LayoutSubViews()，通过Cassowary算法计算各个子视图的位置，算出来后将子视图的Frame从Layout Engine里拷贝出来 —&gt; 和手写布局的绘制、渲染一样。</em></p>
<p>参考：<br><a href="https://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/" target="_blank" rel="noopener">https://ming1016.github.io/2015/11/03/deeply-analyse-autolayout/</a><br><a href="https://github.com/forkingdog/fdstackview" target="_blank" rel="noopener">https://github.com/forkingdog/fdstackview</a><br><a href="https://github.com/facebook/yoga" target="_blank" rel="noopener">https://github.com/facebook/yoga</a><br><a href="https://github.com/ming1016/study/wiki/Masonry" target="_blank" rel="noopener">https://github.com/ming1016/study/wiki/Masonry</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/04/17/iOS创建大小自适应的view/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/04/17/iOS创建大小自适应的view/" itemprop="url">
                  iOS创建大小自适应的view
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-17T17:00:56+08:00">
                2019-04-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>开发中免不了会遇到要定制那种宽高自适应的view。这里做下总结</p>
</blockquote>
<h4 id="1-包括的子view不可滚动（即不包含UIScrollView的别的控件）"><a href="#1-包括的子view不可滚动（即不包含UIScrollView的别的控件）" class="headerlink" title="1. 包括的子view不可滚动（即不包含UIScrollView的别的控件）"></a>1. 包括的子view不可滚动（即不包含UIScrollView的别的控件）</h4><p>这种其实比较好处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;TestView.h&quot;</span><br><span class="line">#import &quot;Masonry.h&quot;</span><br><span class="line"></span><br><span class="line">@interface TestView()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIView *view1;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestView</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithFrame:(CGRect)frame &#123;</span><br><span class="line">if (self = [super initWithFrame:frame]) &#123;</span><br><span class="line">self.backgroundColor = [UIColor redColor];</span><br><span class="line">[self createSubviews];</span><br><span class="line">&#125;</span><br><span class="line">return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)createSubviews &#123;</span><br><span class="line">self.view1 = [[UIView alloc]init];</span><br><span class="line">self.view1.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[self addSubview:self.view1];</span><br><span class="line">[self.view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.left.top.right.bottom.equalTo(self);</span><br><span class="line">make.size.mas_equalTo(CGSizeMake(150, 20));</span><br><span class="line">&#125;];      </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//ViewController.m中</span><br><span class="line">- (void)viewDidLoad &#123;</span><br><span class="line">TestView *test = [[TestView alloc]init];</span><br><span class="line">[self.view addSubview:test];</span><br><span class="line">[test mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.top.equalTo(grayView.mas_bottom).offset(5);</span><br><span class="line">make.centerX.equalTo(self.view);</span><br><span class="line">&#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，只需要设置子视图的边距跟父视图相同，然后设置子视图的宽高即可。<br>但是要注意：<em>在外部给父视图做约束的时候，<code>不要设置跟size相关的属性</code></em><br><img src="https://upload-images.jianshu.io/upload_images/1241385-b3d754b67996dac2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以看到，父视图（红色）和子视图（黄色）大小是一致的。</p>
<h4 id="2-子视图中包括可以滚动的控件（UIScrollView）"><a href="#2-子视图中包括可以滚动的控件（UIScrollView）" class="headerlink" title="2.子视图中包括可以滚动的控件（UIScrollView）"></a>2.子视图中包括可以滚动的控件（UIScrollView）</h4><p>比如这个需求：<br><img src="https://upload-images.jianshu.io/upload_images/1241385-29170cc6c90d429c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/1241385-6b0ead550b43a63b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>要弹出一个alert框，然后根据中间文字的长短，来调整整个框的大小！然后给一个最大高度，如果文字超过了这个高度，则为可滚动。</p>
<p>按照上面的思路，给UIScrollview添加约束，UIScrollView的内部放一个UILabel，然后设置label的约束为四边距跟scrollview相同。我们来测试一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">@interface TestView()</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) UIView *view1; //头部view</span><br><span class="line">@property (nonatomic, strong) UIView *view2; //底部view</span><br><span class="line">@property (nonatomic, strong) UIScrollView *scrollView; </span><br><span class="line">@property (nonatomic, strong) UILabel *content;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">- (void)createSubviews &#123;</span><br><span class="line">self.view1 = [[UIView alloc]init];</span><br><span class="line">self.view1.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[self addSubview:self.view1];</span><br><span class="line">[self.view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.left.top.right.equalTo(self);</span><br><span class="line">make.size.mas_equalTo(CGSizeMake(150, 20));</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.scrollView = [[UIScrollView alloc]init];</span><br><span class="line">self.scrollView.backgroundColor = [UIColor orangeColor];</span><br><span class="line">[self addSubview:self.scrollView];</span><br><span class="line">[self.scrollView mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.left.right.equalTo(self);</span><br><span class="line">make.top.equalTo(self.view1.mas_bottom);</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">self.content = [[UILabel alloc]init];</span><br><span class="line">self.content.text = @&quot;按时；的房价阿斯兰的风景按时；大楼附近奥德赛；立方阿萨德管理局ad；管理会计we；了感觉肉而过；阿夫林的快感骄傲的高考哈尔；快给我如果；卡；管理科见到过；拉的积分；阿刘的时间安排温哥华；按时给家里；的设计费；阿刘四大金刚；卡到房管局；利润空间感；为了国家；打了个健康； 光和热涵盖了看法那个卡了人家给旅客进入那个卡了进入高考了人工；的房价阿斯兰的风景按时；大楼附近奥德赛；立&quot;;</span><br><span class="line">self.content.numberOfLines = 0;</span><br><span class="line">[self.scrollView addSubview:self.content];</span><br><span class="line"></span><br><span class="line">CGSize contentSize = [self.content sizeThatFits:CGSizeMake(150, 9999)];</span><br><span class="line">[self.content mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.edges.equalTo(self.scrollView);</span><br><span class="line">make.size.mas_equalTo(contentSize);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">self.view2 = [[UIView alloc]init];</span><br><span class="line">self.view2.backgroundColor = [UIColor greenColor];</span><br><span class="line">[self addSubview:self.view2];</span><br><span class="line">[self.view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.left.right.bottom.equalTo(self);</span><br><span class="line">make.top.equalTo(self.scrollView.mas_bottom);</span><br><span class="line">make.size.equalTo(self.view1);</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，已经设置了content的四边距和scrollview一致，然后也给了content一个size。<br>然后设置scrollview的左边和右边，跟父视图一致。<br>设置view2的顶部挨着scrollview的底部。<br>然后view2的底部跟父视图底部一致。<br>这个思路跟上面<a href="">1</a>中的，是符合的。<br>但是结果呢？<br><img src="https://upload-images.jianshu.io/upload_images/1241385-f7c249d3fb1c57c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以看到，只有view1和view2，<br><em>UIScrollview并没有显示在页面上</em><br>可见，这个时候，再使用<a href="">1</a>的方法就不行了。（如果是我约束设置错了，还请各位大佬批评指正）</p>
<p>所以这里使用了另外一种思路。</p>
<blockquote>
<p>给scrollview的高度添加约束，然后强引用为一个属性。然后在content文字高度计算完全之后，重新更新此约束，即可修改scrollview的高度。当然，此时子视图的各个控件之间高度的约束就可以忽略了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) NSLayoutConstraint *heightConstraint;</span><br><span class="line"></span><br><span class="line">//这里设置高度约束。初始值为0</span><br><span class="line">self.heightConstraint = [NSLayoutConstraint constraintWithItem:self.scrollView attribute:(NSLayoutAttributeHeight) relatedBy:(NSLayoutRelationEqual) toItem:nil attribute:(NSLayoutAttributeHeight) multiplier:1 constant:0];</span><br><span class="line">[self addConstraint:self.heightConstraint];</span><br><span class="line"></span><br><span class="line">//此处计算完成之后，更新约束值</span><br><span class="line">CGSize contentSize = [self.content sizeThatFits:CGSizeMake(150, 9999)];</span><br><span class="line">[self.content mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">make.edges.equalTo(self.scrollView);</span><br><span class="line">make.size.mas_equalTo(contentSize);</span><br><span class="line">&#125;];</span><br><span class="line">self.heightConstraint.constant = contentSize.height;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<p><img src="https://upload-images.jianshu.io/upload_images/1241385-f8b22a4862d64eb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>此时，可以看到，就能达到我们要的效果。</p>
<p>然后上面的那种弹框中所说的父视图超过最大高度的时候可滚动，可以在获取到高度的时候给约束添加个判断即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">内容label修改行间距</span><br><span class="line"></span><br><span class="line">@param contentStr 要展示的内容字符串</span><br><span class="line">*/</span><br><span class="line">- (void)replaceContentUsingSpecificLineSpacingWithString:(NSString *)contentStr &#123;</span><br><span class="line">NSMutableParagraphStyle *mps = [[NSMutableParagraphStyle alloc]init];</span><br><span class="line">mps.lineSpacing = 6;</span><br><span class="line">mps.lineBreakMode = NSLineBreakByWordWrapping;</span><br><span class="line"></span><br><span class="line">NSDictionary *contentAttributes = @&#123;</span><br><span class="line">NSParagraphStyleAttributeName: mps,</span><br><span class="line">NSFontAttributeName: [UIFont systemFontOfSize: 13],</span><br><span class="line">&#125;;</span><br><span class="line">NSMutableAttributedString *mas = [[NSMutableAttributedString alloc]initWithString:contentStr attributes:contentAttributes];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">self.content.attributedText = mas;</span><br><span class="line">[self layoutIfNeeded];</span><br><span class="line"></span><br><span class="line">if (self.content.height &lt; kPxValue(428)) &#123;</span><br><span class="line">LOG(@&quot;短&quot;);</span><br><span class="line">self.scrollHeightConstraint.constant = self.content.height;</span><br><span class="line">&#125;else &#123;</span><br><span class="line">LOG(@&quot;长&quot;);</span><br><span class="line">self.scrollHeightConstraint.constant = kPxValue(428);</span><br><span class="line">self.contentScrollView.contentSize = CGSizeMake(self.contentScrollView.width,self.content.height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然， 这种效果图，还有一种实现方法：<code>UITextView</code><br>这里有一篇文章可供参考<br><a href="https://www.jianshu.com/p/9e960757de86" target="_blank" rel="noopener">iOS:如何优雅的让UITextView根据输入文字实时改变高度</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/04/15/iOS启动优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/04/15/iOS启动优化/" itemprop="url">
                  iOS启动优化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T11:07:49+08:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>先说结论： 启动时间 = pre-main()时间 + post-main()时间</p>
</blockquote>
<h4 id="App启动过程"><a href="#App启动过程" class="headerlink" title="App启动过程"></a>App启动过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">①解析Info.plist </span><br><span class="line">加载相关信息，例如闪屏</span><br><span class="line">沙箱建立、权限检查</span><br><span class="line">②Mach-O加载 </span><br><span class="line">如果是胖二进制文件，寻找合适当前CPU架构的部分</span><br><span class="line">加载所有依赖的Mach-O文件（递归调用Mach-O加载的方法）</span><br><span class="line">定位内部、外部指针引用，例如字符串、函数等</span><br><span class="line">执行声明为__attribute__((constructor))的C函数</span><br><span class="line">加载类扩展（Category）中的方法</span><br><span class="line">C++静态对象加载、调用ObjC的 +load 函数</span><br><span class="line">③程序执行 </span><br><span class="line">调用main()</span><br><span class="line">调用UIApplicationMain()</span><br><span class="line">调用applicationWillFinishLaunching</span><br></pre></td></tr></table></figure>
<h4 id="一、Pre-Main阶段"><a href="#一、Pre-Main阶段" class="headerlink" title="一、Pre-Main阶段"></a>一、Pre-Main阶段</h4><p>pre-main阶段的定义为APP开始启动到系统调用main函数这一段时间，这个阶段又可以分为这几个步骤</p>
<h5 id="1-Dylib-Loading"><a href="#1-Dylib-Loading" class="headerlink" title="1.Dylib Loading"></a>1.Dylib Loading</h5><h5 id="2-Rebase-Binding-Symbols"><a href="#2-Rebase-Binding-Symbols" class="headerlink" title="2.Rebase/Binding Symbols"></a>2.Rebase/Binding Symbols</h5><p>fix-ups adjust pointers within an image (rebasing) and set pointers that point to symbols outside the image (binding). To speed up rebase/binding time you need fewer pointer fix-ups. Apps with large numbers of Objective-C classes, selectors and categories can add 800ms to launch times (large is 20,000). If your app uses C++ code use less virtual functions. Using Swift Structs is also generally faster.</p>
<h5 id="3-ObjC-Runtime-Setup"><a href="#3-ObjC-Runtime-Setup" class="headerlink" title="3.ObjC Runtime Setup"></a>3.ObjC Runtime Setup</h5><h5 id="4-Initializers"><a href="#4-Initializers" class="headerlink" title="4.Initializers"></a>4.Initializers</h5><p><code>+load</code>是在main函数之前就加载了，<br>而<code>+initialize</code>则是在该类第一次接到消息的时候才会调用，<br>所以，要尽量推后代码的加载时机。<br>但是使用<code>+initialize</code>会有一个问题，也是该方法的调用机制造成的：<br>在使用子类的时候，会先调用父类的<code>+initialize</code>方法。<br>所以，这里可以配合<code>dispatch_once</code>方法来实现类似<code>+load</code>的功能</p>
<p>这一步可以做的优化有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①使用 +initialize 来替代 +load</span><br><span class="line">②不要使用 atribute((constructor)) 将方法显式标记为初始化器，而是让初始化方法调用时才执行。</span><br><span class="line">比如使用 dispatch_once(),pthread_once() 或 std::once()。也就是在第一次使用时才初始化，推迟了一部分工作耗时。</span><br><span class="line">也尽量不要用到C++的静态对象。</span><br><span class="line">③还有一个结论就是swift，编译起来要比OC要快</span><br></pre></td></tr></table></figure></p>
<p>做下总结:<br><img src="https://upload-images.jianshu.io/upload_images/1241385-7eaba2071dca293c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Xcode为我们提供的测试方法："><a href="#Xcode为我们提供的测试方法：" class="headerlink" title="Xcode为我们提供的测试方法："></a>Xcode为我们提供的测试方法：</h4><p>在<code>Edit Scheme</code>-&gt;<code>Arguments</code>-&gt;<code>Environment</code>中添加<code>DYLD_PRINT_STATISTICS</code>，值为<code>1</code><br><img src="https://upload-images.jianshu.io/upload_images/1241385-ca040a890ff8c180.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>再次运行，即可看到各项的结果（皆为毫秒）<br><img src="https://upload-images.jianshu.io/upload_images/1241385-25f5f72bed2a87f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="二、Post-Main-阶段"><a href="#二、Post-Main-阶段" class="headerlink" title="二、Post-Main()阶段"></a>二、Post-Main()阶段</h4><p>这个阶段就是程序加载了main函数之后，到页面展示出来之间的这段时间。<br>这个时间可以这么计算：<br><code>AppDelegate</code>的<code>willFinishLaunchingWithOptions</code>到<code>applicationDidBecomeActive</code>之间的时间，即为post-main()时间<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(nullable NSDictionary *)launchOptions &#123;</span><br><span class="line">NSLog(@&quot;post-main start:%@&quot;,[self getMMTime]);</span><br><span class="line">return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)applicationDidBecomeActive:(UIApplication *)application &#123;</span><br><span class="line">NSLog(@&quot;post-main stop:%@&quot;,[self getMMTime]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-(NSString *)getMMTime&#123;</span><br><span class="line">NSTimeInterval a = [[NSDate date] timeIntervalSince1970] * 1000; // *1000 是精确到毫秒，不乘就是精确到秒</span><br><span class="line">return [NSString stringWithFormat:@&quot;%.0f&quot;, a];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>得出结果为毫秒，相减即得结果。</p>
<h5 id="优化思路："><a href="#优化思路：" class="headerlink" title="优化思路："></a>优化思路：</h5><p><img src="https://upload-images.jianshu.io/upload_images/1241385-e58c1a5b75e5e11d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><h5 id="中文文章"><a href="#中文文章" class="headerlink" title="中文文章"></a>中文文章</h5><p><a href="https://www.jianshu.com/p/cf95d020e1b2" target="_blank" rel="noopener">WWDC之优化App启动速度</a><br><a href="https://www.jianshu.com/p/5efe327ac7ea" target="_blank" rel="noopener">iOS 程序 main函数之前发生什么</a></p>
<h5 id="英文文章"><a href="#英文文章" class="headerlink" title="英文文章"></a>英文文章</h5><p><a href="https://medium.com/@avijeet.dutta13/ios-app-launch-time-analysis-and-optimization-a219ee81447c" target="_blank" rel="noopener">iOS App Launch time analysis and optimizations</a><br><a href="https://techblog.izotope.com/2018/03/08/improving-your-ios-apps-launch-time/" target="_blank" rel="noopener">Improving Your iOS App’s Launch Time</a><br><a href="https://stackoverflow.com/questions/35929530/ios-app-launch-time-measurement" target="_blank" rel="noopener">iOS app launch time measurement</a><br><a href="https://medium.com/@phillfarrugia/xcode-instruments-measuring-launch-time-cpu-usage-memory-leaks-energy-impact-and-frame-rate-1caf8905079f" target="_blank" rel="noopener">Xcode &amp; Instruments: Measuring Launch time, CPU Usage, Memory Leaks, Energy Impact and Frame Rate</a></p>
<h5 id="Apple-Documentation"><a href="#Apple-Documentation" class="headerlink" title="Apple Documentation"></a>Apple Documentation</h5><p><a href="https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html" target="_blank" rel="noopener">The App Life Cycle</a><br><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/DynamicLibraries/100-Articles/OverviewOfDynamicLibraries.html" target="_blank" rel="noopener">Overview of Dynamic Libraries</a><br><a href="https://developer.apple.com/library/archive/documentation/DeveloperTools/Conceptual/MachOTopics/1-Articles/executing_files.html#//apple_ref/doc/uid/TP40001829" target="_blank" rel="noopener">Executing Mach-O Files</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/04/09/Workflow相关/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/04/09/Workflow相关/" itemprop="url">
                  Workflow相关
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-09T11:50:54+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h4><p><a href="https://jiejinghe.com/" target="_blank" rel="noopener">捷径盒</a><br><a href="https://shortcuts.sspai.com/" target="_blank" rel="noopener">少数派</a><br><a href="https://sharecuts.cn/" target="_blank" rel="noopener">捷径社区</a></p>
<p><a href="https://www.zhihu.com/question/27029837/answer/133756961" target="_blank" rel="noopener">iOS 应用 Workflow 有哪些有趣的或能提升生活效率的玩法？</a><br><a href="https://zhuanlan.zhihu.com/p/27758684" target="_blank" rel="noopener">实用好用的捷径(Workflow/Shortcuts)分享，持续更新……</a><br><a href="https://zhuanlan.zhihu.com/p/27334270" target="_blank" rel="noopener">有了Workflow，没想到手机也能这么好用</a><br><a href="https://zhuanlan.zhihu.com/p/26145402" target="_blank" rel="noopener">加上这些干货，让 Workflow 如虎添翼</a><br><a href="https://www.zhihu.com/question/41528582/answer/147984894" target="_blank" rel="noopener">怎样才能让workflow更好用 ？</a><br><a href="https://zhuanlan.zhihu.com/p/45785789" target="_blank" rel="noopener">全网最全 捷径 Workflow 分享（附网站）</a><br><a href="https://www.zhihu.com/question/36073856" target="_blank" rel="noopener">如何方便地将电影片段的台词拼接到一张截图上？</a></p>
<h4 id="教程"><a href="#教程" class="headerlink" title="教程"></a>教程</h4><p><a href="https://help.apple.com/workflow/#/" target="_blank" rel="noopener">Workflow Help</a><br><a href="https://sspai.com/post/27733" target="_blank" rel="noopener">Workflow 教程（一）：Workflow 是款什么样的应用？ | 深度测评</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/04/04/iOS异地上线方式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/04/04/iOS异地上线方式/" itemprop="url">
                  iOS异地上线方式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-04T11:44:29+08:00">
                2019-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>iOS异地上线是什么意思，都有哪些情况？</p>
</blockquote>
<h4 id="异地上线，大概就是外包给一个公司开发项目，然后在拿不到源码的情况下，我们使用自己公司的苹果开发者账号来上线"><a href="#异地上线，大概就是外包给一个公司开发项目，然后在拿不到源码的情况下，我们使用自己公司的苹果开发者账号来上线" class="headerlink" title="异地上线，大概就是外包给一个公司开发项目，然后在拿不到源码的情况下，我们使用自己公司的苹果开发者账号来上线"></a>异地上线，大概就是外包给一个公司开发项目，然后在<strong>拿不到源码的情况下</strong>，我们使用自己公司的苹果开发者账号来上线</h4><p>大致上分为几种思路：</p>
<h5 id="1-苹果开发者账号密码给外包公司"><a href="#1-苹果开发者账号密码给外包公司" class="headerlink" title="1. 苹果开发者账号密码给外包公司"></a>1. 苹果开发者账号密码给外包公司</h5><p>这种方法。。。。emmmmmm，自行体会。。。</p>
<h5 id="2-使用苹果公司提供的授权方式"><a href="#2-使用苹果公司提供的授权方式" class="headerlink" title="2. 使用苹果公司提供的授权方式"></a>2. 使用苹果公司提供的授权方式</h5><p><a href="https://developer.apple.com" target="_blank" rel="noopener">苹果开发者</a>登录账号之后，有个member栏目，<br><strong>然后把别的个人账户添加到要上线的公司账户的组织下面</strong>，<br>此时在xcode中账户设置里面输入个人账户，应该就可以正常上传应用了。</p>
<h5 id="3-分享p12和mobileProvision文件（只是思路，不确定可不可行）"><a href="#3-分享p12和mobileProvision文件（只是思路，不确定可不可行）" class="headerlink" title="3. 分享p12和mobileProvision文件（只是思路，不确定可不可行）"></a>3. 分享p12和mobileProvision文件（只是思路，不确定可不可行）</h5><h6 id="分两步：1-先创建p12证书"><a href="#分两步：1-先创建p12证书" class="headerlink" title="分两步：1.先创建p12证书"></a>分两步：1.先创建p12证书</h6><p>先在<code>钥匙串</code>-&gt;<code>证书助手</code>-&gt;<code>从证书机构请求证书</code><br><img src="https://upload-images.jianshu.io/upload_images/1241385-57765779ad8e6d35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>请求完成之后，下载，然后就可以在钥匙串中找到了<br>然后在想要生成p12文件的证书上，<code>右键导出</code><br><img src="https://upload-images.jianshu.io/upload_images/1241385-f2a5e47b3ec6fa2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>然后输入要保存的名字，以及路径<br><img src="https://upload-images.jianshu.io/upload_images/1241385-2366f7d401e09eb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>可以看到文件后缀名为<code>p12</code>类型</p>
<h6 id="2-然后创建profile-provision-配置文件-文件"><a href="#2-然后创建profile-provision-配置文件-文件" class="headerlink" title="2.然后创建profile provision(配置文件)文件"></a>2.然后创建profile provision(配置文件)文件</h6><p>在<a href="https://developer.apple.com" target="_blank" rel="noopener">苹果开发者</a>的<code>证书管理</code>里边，新建配置文件<br>（开发和发布的要分开）</p>
<p>创建完成这两个文件之后，就可以把他们发给开发人员了。<br>只需要双击文件之后，这些配置就会被存到<code>钥匙串</code>中。<br>然后在Xcode中就可以选择<code>Profile Provisioning</code>文件中对应的team了（我的猜想）</p>
<p><a href="https://support.mobincube.com/hc/en-us/articles/200511933-How-to-get-the-p12-file-and-provisioning-profile-for-publishing-an-app-on-App-Store" target="_blank" rel="noopener">https://support.mobincube.com/hc/en-us/articles/200511933-How-to-get-the-p12-file-and-provisioning-profile-for-publishing-an-app-on-App-Store</a></p>
<h5 id="4-IPA包重签名"><a href="#4-IPA包重签名" class="headerlink" title="4. IPA包重签名"></a>4. IPA包重签名</h5><p><a href="https://github.com/WooNoah/ios-app-signer" target="_blank" rel="noopener">GitHub上有第三方工具 ios-app-signer</a><br>他是一个Mac APP，下载之后运行，就可以看到以下界面<br><img src="https://upload-images.jianshu.io/upload_images/1241385-b8cafc92a9e92c0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p><strong>这里要注意几点：</strong><br><strong>前三项是必选的！！！</strong><br><strong><em>选对<code>签名证书</code>(Signing Certificate) 和 <code>配置文件</code>(Profile Provisioning)</em></strong><br><strong><code>配置文件</code>(Profile Provisioning)</strong>可能需要先按照上面<a href="">3.2</a>的步骤生成一个，然后再选择</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://woonoah.github.io/woodi.github.io/woodi.github.io/2019/04/02/setNeedsLayout-setNeedsDisplay-viewDidLayoutSubviews区别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="D">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/woodi.github.io/images/profileIcon.png">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Woooodi's Private Zone">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/woodi.github.io/2019/04/02/setNeedsLayout-setNeedsDisplay-viewDidLayoutSubviews区别/" itemprop="url">
                  setNeedsLayout setNeedsDisplay viewDidLayoutSubviews区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-02T15:39:48+08:00">
                2019-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <blockquote>
<p>对当前了解的知识点做下总结</p>
</blockquote>
<h4 id="iOS-Layout机制相关方法"><a href="#iOS-Layout机制相关方法" class="headerlink" title="iOS Layout机制相关方法"></a>iOS Layout机制相关方法</h4><ol>
<li>修改view的frame<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (void)sizeToFit</span><br><span class="line">- (CGSize)sizeThatFits:(CGSize)size</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol start="2">
<li>告诉系统来刷新布局<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)layoutIfNeeded</span><br><span class="line">- (void)setNeedsLayout</span><br><span class="line">//布局控件的方法</span><br><span class="line">- (void)layoutSubviews</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<ol start="3">
<li>告诉系统来绘制<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)setNeedsDisplay</span><br><span class="line">//绘制方法</span><br><span class="line">- (void)drawRect</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/woodi.github.io/2019/04/02/setNeedsLayout-setNeedsDisplay-viewDidLayoutSubviews区别/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/woodi.github.io/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/woodi.github.io/page/6/">6</a><a class="extend next" rel="next" href="/woodi.github.io/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>


          
          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/woodi.github.io/images/profileIcon.png" alt="D">
          <p class="site-author-name" itemprop="name">D</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/woodi.github.io/archives">
                <span class="site-state-item-count">58</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">标签</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">D</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  




  
  <script type="text/javascript" src="/woodi.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/woodi.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/woodi.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/woodi.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/woodi.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/woodi.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/woodi.github.io/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/woodi.github.io/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/woodi.github.io/js/src/bootstrap.js?v=5.1.0"></script>



  



  




	





  





  





  



  
  

  

  

  

  


  

</body>
</html>
